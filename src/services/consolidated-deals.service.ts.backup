import { steamAdapter } from '../adapters/steam.adapter.js'
// import { epicAdapter } from '../adapters/e        // Validar novamente antes de adicionar (dupla verifica√ß√£o)
        if (offer.priceBase > 0 && offer.priceFinal >= 0) {
          // Adicionar esta loja ao jogo existente
          existingGame.stores.push({
            store: offer.store,
            storeAppId: offer.storeAppId,
            url: offer.url,
            priceBase: offer.priceBase,
            priceFinal: offer.priceFinal,
            discountPct: offer.discountPct,
            isActive: offer.isActive
          })
        } else {
          console.warn(`Skipped adding invalid store data for ${offer.title}: base=${offer.priceBase}, final=${offer.priceFinal}`)
        }r.js' // Desativado temporariamente para melhorias
import { Off            bestPrice: {
              store: offer.store,
              price: offer.priceFinal,
              discountPct: offer.discountPct
            },
            totalStores: 1
          }
          
          gameMap.set(normalizedTitle, newGame)
        } else {
          console.warn(`Skipped creating game with invalid price data: ${offer.title} (base=${offer.priceBase}, final=${offer.priceFinal})`)
        } from '../adapters/types.js'

export interface ConsolidatedDeal {
  id: string
  title: string
  slug: string
  coverUrl?: string
  genres?: string[]
  tags?: string[]
  stores: Array<{
    store: 'steam' // | 'epic' - Epic temporariamente desativada para melhorias
    storeAppId: string
    url: string
    priceBase: number
    priceFinal: number
    discountPct: number
    isActive: boolean
  }>
  bestPrice: {
    store: string
    price: number
    discountPct: number
  }
  totalStores: number
}

// Fun√ß√£o para normalizar t√≠tulos de jogos para compara√ß√£o
function normalizeTitle(title: string): string {
  return title
    .toLowerCase()
    .replace(/[^\w\s]/g, '') // Remove caracteres especiais
    .replace(/\s+/g, ' ') // Normaliza espa√ßos
    .trim()
    .replace(/(\s|^)(the|a|an)\s/g, ' ') // Remove artigos
    .replace(/\s(game|edition|deluxe|ultimate|goty|complete)$/g, '') // Remove sufixos comuns
}

// Fun√ß√£o para gerar slug √∫nico baseado no t√≠tulo
function generateSlug(title: string): string {
  return title
    .toLowerCase()
    .replace(/[^\w\s]/g, '')
    .replace(/\s+/g, '-')
    .trim()
}

// Fun√ß√£o para verificar se dois jogos s√£o o mesmo
function isSameGame(title1: string, title2: string): boolean {
  const normalized1 = normalizeTitle(title1)
  const normalized2 = normalizeTitle(title2)
  
  // Compara√ß√£o exata
  if (normalized1 === normalized2) return true
  
  // Verificar se um t√≠tulo cont√©m o outro (para diferentes edi√ß√µes)
  if (normalized1.includes(normalized2) || normalized2.includes(normalized1)) {
    const diff = Math.abs(normalized1.length - normalized2.length)
    return diff <= 10 // Diferen√ßa pequena, provavelmente mesmo jogo
  }
  
  return false
}

export async function fetchConsolidatedDeals(limit: number = 50): Promise<ConsolidatedDeal[]> {
  console.log('üîç Buscando ofertas de todas as lojas...')
  
  try {
    // Buscar ofertas de Steam (Epic temporariamente desativada para melhorias)
    const steamOffers = await steamAdapter.fetchTrending().catch((err: any) => {
      console.log('Steam adapter falhou:', err.message)
      return []
    })
    
    // Epic Games temporariamente desativada para melhorias
    const epicOffers = [] // Desativado temporariamente
    console.log(`üìä Ofertas encontradas: Steam(${steamOffers.length}), Epic(temporariamente desativada)`)

    // Mapa para consolidar jogos por t√≠tulo normalizado
    const gameMap = new Map<string, ConsolidatedDeal>()

    // Processar ofertas de cada loja (apenas Steam por enquanto)
    const allOffers = [
      ...steamOffers.map((o: any) => ({ ...o, store: 'steam' as const }))
      // ...epicOffers.map((o: any) => ({ ...o, store: 'epic' as const })) // Desativado temporariamente
    ]

    // Fun√ß√£o para validar se a oferta tem dados reais v√°lidos
    function isValidOffer(offer: OfferDTO): boolean {
      // Bloquear ofertas sem pre√ßo base v√°lido
      if (!offer.priceBase || offer.priceBase <= 0) {
        console.warn(`Offer blocked: Invalid base price for ${offer.title} (${offer.priceBase})`)
        return false
      }
      
      // Bloquear ofertas sem pre√ßo final v√°lido
      if (!offer.priceFinal || offer.priceFinal < 0) {
        console.warn(`Offer blocked: Invalid final price for ${offer.title} (${offer.priceFinal})`)
        return false
      }
      
      // Bloquear ofertas com discount negativo ou inv√°lido
      if (offer.discountPct < 0 || offer.discountPct > 100) {
        console.warn(`Offer blocked: Invalid discount for ${offer.title} (${offer.discountPct}%)`)
        return false
      }
      
      // Bloquear ofertas sem t√≠tulo v√°lido
      if (!offer.title || offer.title.trim().length === 0 || offer.title === 'Steam Game') {
        console.warn(`Offer blocked: Invalid title for ${offer.storeAppId}`)
        return false
      }
      
      return true
    }

    for (const offer of allOffers) {
      if (!offer.isActive) continue
      
      // Validar se a oferta tem dados reais v√°lidos
      if (!isValidOffer(offer)) continue

      const normalizedTitle = normalizeTitle(offer.title)
      let existingGame: ConsolidatedDeal | null = null
      let existingKey: string | null = null

      // Procurar se j√° existe um jogo similar
      for (const [key, game] of gameMap.entries()) {
        if (isSameGame(offer.title, game.title)) {
          existingGame = game
          existingKey = key
          break
        }
      }

      if (existingGame && existingKey) {
        // Adicionar loja ao jogo existente
        existingGame.stores.push({
          store: offer.store,
          storeAppId: offer.storeAppId,
          url: offer.url,
          priceBase: offer.priceBase,
          priceFinal: offer.priceFinal,
          discountPct: offer.discountPct,
          isActive: offer.isActive
        })

        // Atualizar melhor pre√ßo (considerando pre√ßos v√°lidos)
        const currentPrice = offer.priceFinal || 0
        const existingPrice = existingGame.bestPrice.price || 0
        
        if (currentPrice > 0 && (existingPrice === 0 || currentPrice < existingPrice)) {
          existingGame.bestPrice = {
            store: offer.store,
            price: currentPrice,
            discountPct: offer.discountPct || 0
          }
        }

        // Recalcular melhor pre√ßo ap√≥s adicionar nova loja
        const validStores = existingGame.stores.filter(s => s.priceFinal > 0)
        if (validStores.length > 0) {
          const cheapestStore = validStores.sort((a, b) => a.priceFinal - b.priceFinal)[0]
          existingGame.bestPrice = {
            store: cheapestStore.store,
            price: cheapestStore.priceFinal,
            discountPct: cheapestStore.discountPct || 0
          }
        }

        existingGame.totalStores = existingGame.stores.length

        // Usar a capa mais bonita (prioridade: Steam > Epic)
        if (offer.coverUrl && (!existingGame.coverUrl || offer.store === 'steam')) {
          existingGame.coverUrl = offer.coverUrl
        }

        // Mesclar g√™neros e tags
        if (offer.genres) {
          const existingGenres = new Set(existingGame.genres || [])
          offer.genres.forEach((genre: string) => existingGenres.add(genre))
          existingGame.genres = Array.from(existingGenres)
        }

        if (offer.tags) {
          const existingTags = new Set(existingGame.tags || [])
          offer.tags.forEach((tag: string) => existingTags.add(tag))
          existingGame.tags = Array.from(existingTags)
        }

      } else {
        // Criar novo jogo consolidado
        const slug = generateSlug(offer.title)
        const consolidatedGame: ConsolidatedDeal = {
          id: `game-${slug}-${offer.storeAppId}`, // ID √∫nico e consistente
          title: offer.title,
          slug,
          coverUrl: offer.coverUrl,
          genres: offer.genres || [],
          tags: offer.tags || [],
          stores: [{
            store: offer.store,
            storeAppId: offer.storeAppId,
            url: offer.url,
            priceBase: offer.priceBase || 0,
            priceFinal: offer.priceFinal || 0,
            discountPct: offer.discountPct || 0,
            isActive: offer.isActive
          }],
          bestPrice: {
            store: offer.store,
            price: offer.priceFinal || 0,
            discountPct: offer.discountPct || 0
          },
          totalStores: 1
        }

        gameMap.set(normalizedTitle, consolidatedGame)
      }
    }

    // Converter para array e ordenar por desconto (n√£o por n√∫mero de lojas)
    const consolidatedDeals = Array.from(gameMap.values())
      .sort((a, b) => {
        // Primeiro por desconto (maior primeiro)
        if (b.bestPrice.discountPct !== a.bestPrice.discountPct) {
          return b.bestPrice.discountPct - a.bestPrice.discountPct
        }
        // Depois por pre√ßo final (menor primeiro)
        return (a.bestPrice.price || 0) - (b.bestPrice.price || 0)
      })
      .slice(0, limit)

    console.log(`‚úÖ Consolidados: ${consolidatedDeals.length} jogos √∫nicos`)
    console.log(`üè™ Jogos em m√∫ltiplas lojas: ${consolidatedDeals.filter(d => d.totalStores > 1).length}`)

    return consolidatedDeals

  } catch (error) {
    console.error('‚ùå Erro ao consolidar ofertas:', error)
    return []
  }
}